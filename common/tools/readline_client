#!/usr/bin/python

# Lighthead-bot and this programm is part of a HRI PhD project at
#  the University of Plymouth,
#  a Robotic Animation System including face, eyes, head and other
#  supporting algorithms for vision and basic emotions.  
# Copyright (C) 2010 Frederic Delaunay, frederic.delaunay@plymouth.ac.uk

#  This program is free software: you can redistribute it and/or
#   modify it under the terms of the GNU General Public License as
#   published by the Free Software Foundation, either version 3 of the
#   License, or (at your option) any later version.

#  This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.

#  You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

#
# Windows users: you need pyreadline from PyPI (http://pypi.python.org/pypi).
#


import threading
import readline
import logging
import atexit
import sys
import cmd
import os

import comm

# set logging verbosity
# TODO: set it for the module only
logging.basicConfig(level=logging.WARNING, format=comm.FORMAT)

# readline history
HISTFILE=os.path.join(os.environ["HOME"], ".comm-cons-clent.history")
try:
    readline.read_history_file(HISTFILE)
except IOError:
    pass
import atexit
atexit.register(readline.write_history_file, HISTFILE)

class myUI(cmd.Cmd):
    def __init__(self):
        self.use_rawinput = True # False # For MinGW ?
        print "enter 'EOF' or press ^D to quit"
        self.prompt = "<connecting ...>"
        cmd.Cmd.__init__(self)
        self.server = None
        threading.Thread(target=self.cmdloop).start()

    def default(self, line):
        if line and self.server and self.server.status == "connected":
            self.server.send_msg(line)
        if line in [ 'EOF', 'bye' ]:
            if self.server:
                self.server.running = False

    def emptyline(self):
        """forget the command when no command is given"""
        pass

    def postcmd(self, stop, line):
        """return True to stop readline thread"""
        if not self.server or not self.server.running:
            print "exiting"
            readline.write_history_file(HISTFILE)
            return True

    def preloop(self):
        self.prompt = "%s> " % (self.server and self.server.status or '--')

    def redraw_prompt(self):
        self.preloop()
        print self.prompt,
        self.stdout.flush()


class commConsClient(comm.BaseClient):
    """Our connection to a target server"""

    def __init__(self, addr_port, ui=None):
        self.status = "connecting"
        self.ui = ui
        if self.ui :
            self.ui.server = self
            threading.Thread(target=ui.cmdloop).start()
        try:
            comm.BaseClient.__init__(self, addr_port)
            self.connect_and_run()
        except comm.error, e:
            print "\n"+str(e)
            self.handle_error()
        except Exception, e:
            if self.ui:
                self.ui.running = False
            raise

    def handle_connect(self):
        """Called when the client has just connected successfully"""
        self.status = "connected"
        if self.ui:
            print "\nnow connected to", self.target_addr
            self.ui.redraw_prompt()

    def handle_disconnect(self):
        self.status = "disconnected"
        self.running = False

    def handle_error(self, e):
        print "\nCommunication error:", e
        self.handle_disconnect()
        print "press enter to finish"

    def handle_timeout(self):
        """Called when timeout waiting for data has expired."""
        if pipe_mode:
            line = sys.stdin.readline()
            while line:
                print sys.argv[0],"sending>", line
                self.send(line)
                line = sys.stdin.readline()
                if self.status == "disconnected":
                    self.running = False
                    return

    def process(self, line):
        """method that handles incoming data (line by line)."""
        if not line:
            return 0
        print "\n", line
        if self.ui:
            self.ui.redraw_prompt()
        return len(line)


if __name__ == "__main__":
    if len(sys.argv) < 3:
        print "[--pipe] address and port not given!"
        exit(-1)

    pipe_mode =  sys.argv[1] == '--pipe' and sys.argv.pop(1)
    port = sys.argv[2].isdigit() and int(sys.argv[2]) or sys.argv[2]

    commConsClient((sys.argv[1], port), not pipe_mode and myUI())
