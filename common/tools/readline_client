#!/usr/bin/python

import threading
import readline
import logging
import atexit
import sys
import cmd
import os

import comm

# set logging verbosity
# TODO: set it for the module only
logging.basicConfig(level=logging.WARNING, format=comm.FORMAT)

# readline history
HISTFILE=os.path.join(os.environ["HOME"], ".comm-cons-clent.history")
try:
    readline.read_history_file(HISTFILE)
except IOError:
    pass
import atexit
atexit.register(readline.write_history_file, HISTFILE)
del os, HISTFILE

#
#
#

class myUI(cmd.Cmd):
    def precmd(self, line):
        if not hasattr(self, "server"):
            self.prompt = "<connecting>"
        else:
            self.prompt = (self.server.connected and self.server.addr + "> " or
                           "<disconnected> " )
        return line

    def default(self, line):
        if line:
            self.server.send_msg(line)

    def restore_prompt(self):
        self.stdout.write(self.prompt)
        self.stdout.flush()


class commConsClient(comm.BasicHandler):
    """Our connection to a target server"""

    def __init__(self, addr_port, pipe_mode):
        self.ui = not pipe_mode and self.create_ui() or None
        comm.BasicHandler.__init__(self)
        # we're asking for our client to connect to server, but we don't know
        # when this will happen, so rely on handle_connect to be noticed.
        try:
            self.connect_to(addr_port)
        except UserWarning, err:
            print sys.argv[0], "FATAL ERROR", err
            exit(-1)

    def create_ui(self):
        ui = myUI()
        ui.precmd("")
        ui.use_rawinput = True
        ui.server = self
        return ui
   
    def handle_connect(self):
        """Called when the client has just connected successfully"""
        if self.ui == None:
            return
        if comm.BasicHandler.handle_connect(self):
            print sys.argv[0], "now connected to", self.addr
        else:
            print sys.argv[0], "failed to connect to", self.addr
        self.ui.precmd("")

    def process(self, line):
        """method that handles incoming data (line by line)."""
        print "\nreceived from server:", line
        if self.ui:
            self.ui.restore_prompt()
        return len(line)


TIMER=None
if __name__ == "__main__":
    if len(sys.argv) < 3:
        print "(--pipe) address and port not given!"
        exit(-1)

    pipe_mode =  sys.argv[1] == '--pipe' and sys.argv.pop(1)
    conn = commConsClient((sys.argv[1], sys.argv[2]), pipe_mode)

    if pipe_mode:
        line = sys.stdin.readline()
        while line:
            print sys.argv[0],"sending>", line
            conn.send_msg(line)
            line = sys.stdin.readline()
            comm.loop(count=1)
            if not conn.connected:
                print "disconnected from remote"
                exit(-1)
    else:
        def pump():
            """We need that because readline loop is blocking"""
            comm.loop(0.1, count=1)
            TIMER = threading.Timer(0.2, pump)
            TIMER.start()

        pump()
        try:
            conn.ui.cmdloop()
        except:
            print "\n--done--"
            exit(-1)
