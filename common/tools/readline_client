#!/usr/bin/python

# Lighthead-bot and this programm is part of a HRI PhD project at
#  the University of Plymouth,
#  a Robotic Animation System including face, eyes, head and other
#  supporting algorithms for vision and basic emotions.  
# Copyright (C) 2010 Frederic Delaunay, frederic.delaunay@plymouth.ac.uk

#  This program is free software: you can redistribute it and/or
#   modify it under the terms of the GNU General Public License as
#   published by the Free Software Foundation, either version 3 of the
#   License, or (at your option) any later version.

#  This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.

#  You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

#
# Windows users: you need pyreadline from PyPI (http://pypi.python.org/pypi).
#


import threading
import readline
import logging
import atexit
import sys
import cmd
import os

import comm

# set logging verbosity
# TODO: set it for the module only
logging.basicConfig(level=logging.WARNING, format=comm.FORMAT)

# readline history
HISTFILE=os.path.join(os.environ["HOME"], ".comm-cons-clent.history")
try:
    readline.read_history_file(HISTFILE)
except IOError:
    pass
import atexit
atexit.register(readline.write_history_file, HISTFILE)
del os, HISTFILE


class myUI(cmd.Cmd):
    def __init__(self):
        self.use_rawinput = True #False
        self.prompt = "<connecting ...>"
        print "press ^D to quit"
        cmd.Cmd.__init__(self)
        self.running = True
        threading.Thread(target=self.cmdloop).start()

    def default(self, line):
        if line and self.server:
            self.server.send_msg(line)
        elif line in [ 'EOF', 'bye' ]:
            sys.exit(0)

    def emptyline(self):
        """forget the command when no command is given"""
        pass

    def postcmd(self, stop, line):
        return not self.running

    def disconnected(self):
        self.server = None
        self.prompt = "<disconnected> "
        self.redraw_prompt()

    def redraw_prompt(self):
        self.stdout.write(self.prompt)
        self.stdout.flush()


class commConsClient(comm.BaseClient):
    """Our connection to a target server"""

    def __init__(self, addr_port, ui=None):
        self.ui = ui
        if self.ui :
            self.ui.server = self
        try:
#            import pdb; pdb.set_trace()
            comm.BaseClient.__init__(self, addr_port)
            self.connect_and_run()
        except comm.error, e:
            print "\n"+str(e)
            self.handle_error()
        except Exception, e:
            if self.ui:
                print e, "\nI'm dying please press Enter !!!"
                self.ui.running = False

    def handle_connect(self):
        """Called when the client has just connected successfully"""
        if self.ui:
            print "\nnow connected to %s" % self.target_addr
            if type(self.target_addr) == type(""):
                info = ("localhost", self.target_addr)
            self.ui.prompt = info[0] + "> "
            self.ui.redraw_prompt()

    def handle_disconnect(self):
        if self.ui:
            self.ui.disconnected()

    def handle_error(self, e):
        print "\nCommunication error", e
        if self.ui:
            self.ui.disconnected()

    def handle_timeout(self):
        """Called when timeout waiting for data has expired."""
        print "timeout"
        if pipe_mode:
            line = sys.stdin.readline()
            while line:
                print sys.argv[0],"sending>", line
                self.send(line)
                line = sys.stdin.readline()
                if not self.connected:
                    print "disconnected from remote"
                    exit(-1)

    def process(self, line):
        """method that handles incoming data (line by line)."""
        print "\n", line
        if self.ui:
            self.ui.redraw_prompt()
        return len(line)


if __name__ == "__main__":
    if len(sys.argv) < 3:
        print "[--pipe] address and port not given!"
        exit(-1)

    pipe_mode =  sys.argv[1] == '--pipe' and sys.argv.pop(1)
    port = sys.argv[2].isdigit() and int(sys.argv[2]) or sys.argv[2]

    commConsClient((sys.argv[1], port), not pipe_mode and myUI())
